From 486c77715c9ddd65a51357866227ed40a19f9a54 Mon Sep 17 00:00:00 2001
From: "Luke D. Jones" <luke@ljones.dev>
Date: Sat, 28 Aug 2021 20:00:46 +1200
Subject: [PATCH v6 1/1] asus-wmi: Add support for custom fan curves

Add support for custom fan curves found on some ASUS ROG laptops.

These laptops have the ability to set a custom curve for the CPU
and GPU fans via an ACPI method call. This patch enables this,
additionally enabling custom fan curves per-profile, where profile
here means each of the 3 levels of "throttle_thermal_policy".

Signed-off-by: Luke D. Jones <luke@ljones.dev>
---
 drivers/platform/x86/asus-wmi.c            | 617 ++++++++++++++++++++-
 include/linux/platform_data/x86/asus-wmi.h |   2 +
 2 files changed, 617 insertions(+), 2 deletions(-)

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index cc5811844012..e2538e47c224 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -106,8 +106,19 @@ module_param(fnlock_default, bool, 0444);
 
 #define WMI_EVENT_MASK			0xFFFF
 
+#define NUM_FAN_CURVE_POINTS	8
+#define NUM_FAN_CURVE_DATA	NUM_FAN_CURVE_POINTS * 2
+
 static const char * const ashs_ids[] = { "ATK4001", "ATK4002", NULL };
 
+/*
+ * The order here matters, index positions reflect
+ * ASUS_THROTTLE_THERMAL_POLICY_*
+*/
+static const char * const fan_curve_names[] = { "balanced", "performance", "quiet" };
+
+static int throttle_thermal_policy_write(struct asus_wmi*);
+
 static bool ashs_present(void)
 {
 	int i = 0;
@@ -122,7 +133,8 @@ struct bios_args {
 	u32 arg0;
 	u32 arg1;
 	u32 arg2; /* At least TUF Gaming series uses 3 dword input buffer. */
-	u32 arg4;
+	u32 arg3;
+	u32 arg4; /* Some ROG laptops require a full 5 input args */
 	u32 arg5;
 } __packed;
 
@@ -173,6 +185,44 @@ enum fan_type {
 	FAN_TYPE_SPEC83,	/* starting in Spec 8.3, use CPU_FAN_CTRL */
 };
 
+/*
+ * The curve_profile_type is linked with ASUS_THROTTLE_THERMAL_POLICY within
+ * the related ACPI call which means that there are only 3 possible profiles.
+ * Because ASUS_THROTTLE_THERMAL_POLICY is also linked with platform_profile
+ * we'll refer to the throttle profiles by the related platform_profile names.
+*/
+enum curve_profile_type {
+	FAN_CURVE_PROFILE_BALANCED = 0,
+	FAN_CURVE_PROFILE_PERFORMANCE,
+	FAN_CURVE_PROFILE_QUIET,
+	NUM_FAN_CURVE_PROFILES,
+};
+
+/*
+ * Each temps[n] is paired with percents[n]
+*/
+struct fan_curve_data {
+	u8 temps[NUM_FAN_CURVE_POINTS];
+	u8 percents[NUM_FAN_CURVE_POINTS];
+};
+
+/*
+ * The related ACPI method for testing availability also returns the factory
+ * default fan curves. We save them here so that a user can reset custom
+ * settings if required.
+*/
+struct throttle_fan_curve {
+	bool enabled;
+	struct fan_curve_data cpu;
+	struct fan_curve_data cpu_default;
+	struct fan_curve_data gpu;
+	struct fan_curve_data gpu_default;
+};
+
+static ssize_t fan_curve_store(struct asus_wmi *asus, const char *buf,
+				size_t count, u32 dev,
+				struct throttle_fan_curve *curve);
+
 struct asus_wmi {
 	int dsts_id;
 	int spec;
@@ -220,6 +270,10 @@ struct asus_wmi {
 	bool throttle_thermal_policy_available;
 	u8 throttle_thermal_policy_mode;
 
+	bool cpu_fan_curve_available;
+	bool gpu_fan_curve_available;
+	struct throttle_fan_curve throttle_fan_curves[NUM_FAN_CURVE_PROFILES];
+
 	struct platform_profile_handler platform_profile_handler;
 	bool platform_profile_support;
 
@@ -285,6 +339,85 @@ int asus_wmi_evaluate_method(u32 method_id, u32 arg0, u32 arg1, u32 *retval)
 }
 EXPORT_SYMBOL_GPL(asus_wmi_evaluate_method);
 
+static int asus_wmi_evaluate_method5(u32 method_id,
+		u32 arg0, u32 arg1, u32 arg2, u32 arg3, u32 arg4, u32 *retval)
+{
+	struct bios_args args = {
+		.arg0 = arg0,
+		.arg1 = arg1,
+		.arg2 = arg2,
+		.arg3 = arg3,
+		.arg4 = arg4,
+	};
+	struct acpi_buffer input = { (acpi_size) sizeof(args), &args };
+	struct acpi_buffer output = { ACPI_ALLOCATE_BUFFER, NULL };
+	acpi_status status;
+	union acpi_object *obj;
+	u32 tmp = 0;
+
+	status = wmi_evaluate_method(ASUS_WMI_MGMT_GUID, 0, method_id,
+				     &input, &output);
+
+	if (ACPI_FAILURE(status))
+		return -EIO;
+
+	obj = (union acpi_object *)output.pointer;
+	if (obj && obj->type == ACPI_TYPE_INTEGER)
+		tmp = (u32) obj->integer.value;
+
+	if (retval)
+		*retval = tmp;
+
+	kfree(obj);
+
+	if (tmp == ASUS_WMI_UNSUPPORTED_METHOD)
+		return -ENODEV;
+
+	return 0;
+}
+
+/*
+ * Returns as an error if the method output is not a buffer. Typically this
+ * means that the method called is unsupported.
+*/
+static int asus_wmi_evaluate_method_buf(u32 method_id,
+		u32 arg0, u32 arg1, u8 *ret_buffer)
+{
+	struct bios_args args = {
+		.arg0 = arg0,
+		.arg1 = arg1,
+		.arg2 = 0,
+	};
+	struct acpi_buffer input = { (acpi_size) sizeof(args), &args };
+	struct acpi_buffer output = { ACPI_ALLOCATE_BUFFER, NULL };
+	acpi_status status;
+	union acpi_object *obj;
+	u32 int_tmp = 0;
+
+	status = wmi_evaluate_method(ASUS_WMI_MGMT_GUID, 0, method_id,
+				     &input, &output);
+
+	if (ACPI_FAILURE(status))
+		return -EIO;
+
+	obj = (union acpi_object *)output.pointer;
+
+	if (obj && obj->type == ACPI_TYPE_INTEGER) {
+		int_tmp = (u32) obj->integer.value;
+		if (int_tmp == ASUS_WMI_UNSUPPORTED_METHOD)
+			return -ENODEV;
+		return int_tmp;
+	}
+
+	if (obj && obj->type == ACPI_TYPE_BUFFER) {
+		memcpy(ret_buffer, obj->buffer.pointer, obj->buffer.length);
+	}
+
+	kfree(obj);
+
+	return 0;
+}
+
 static int asus_wmi_evaluate_method_agfn(const struct acpi_buffer args)
 {
 	struct acpi_buffer input;
@@ -2043,6 +2176,450 @@ static ssize_t fan_boost_mode_store(struct device *dev,
 // Fan boost mode: 0 - normal, 1 - overboost, 2 - silent
 static DEVICE_ATTR_RW(fan_boost_mode);
 
+/* Custom fan curves per-profile **********************************************/
+
+static void copy_fan_curve_buf(struct fan_curve_data *data, u8 *buf)
+{
+	int i;
+
+	for (i = 0; i < NUM_FAN_CURVE_POINTS; i++) {
+		data->temps[i] = buf[i];
+	}
+	for (i = 0; i < NUM_FAN_CURVE_POINTS; i++) {
+		data->percents[i] = buf[i + 8];
+	}
+}
+
+static void init_fan_curve(struct throttle_fan_curve *curves,
+			       u8 *buf, u32 dev)
+{
+	if (dev == ASUS_WMI_DEVID_CPU_FAN_CURVE) {
+		copy_fan_curve_buf(&curves->cpu, buf);
+		copy_fan_curve_buf(&curves->cpu_default, buf);
+	} else {
+		copy_fan_curve_buf(&curves->gpu, buf);
+		copy_fan_curve_buf(&curves->gpu_default, buf);
+	}
+}
+
+/*
+ * Check if the ability to set fan curves on either fan exists, and store the
+ * defaults for recall later plus to provide users with a starting point.
+ *
+ * "dev" is either CPU_FAN_CURVE or GPU_FAN_CURVE.
+*/
+static int custom_fan_check_present(struct asus_wmi *asus,
+				    bool *available, u32 dev)
+{
+	struct throttle_fan_curve *curves;
+	u8 buf[NUM_FAN_CURVE_DATA];
+	int err;
+
+	*available = false;
+
+	/* Balanced default */
+	curves = &asus->throttle_fan_curves[FAN_CURVE_PROFILE_BALANCED];
+	err = asus_wmi_evaluate_method_buf(asus->dsts_id, dev, 0, buf);
+	if (err) {
+		if (err == -ENODEV)
+			return 0;
+		return err;
+	}
+	init_fan_curve(curves, buf, dev);
+
+	/*
+	 * Quiet default. The index num for ACPI method does not match the
+	 * throttle_thermal number, same for Performance.
+	*/
+	curves = &asus->throttle_fan_curves[FAN_CURVE_PROFILE_QUIET];
+	err = asus_wmi_evaluate_method_buf(asus->dsts_id, dev, 1, buf);
+	if (err) {
+		if (err == -ENODEV)
+			return 0;
+		return err;
+	}
+	init_fan_curve(curves, buf, dev);
+
+	/* Performance default */
+	curves = &asus->throttle_fan_curves[FAN_CURVE_PROFILE_PERFORMANCE];
+	err = asus_wmi_evaluate_method_buf(asus->dsts_id, dev, 2, buf);
+	if (err) {
+		if (err == -ENODEV)
+			return 0;
+		return err;
+	}
+	init_fan_curve(curves, buf, dev);
+
+	*available = true;
+	return 0;
+}
+
+static ssize_t fan_curve_show(char *buf, u32 device,
+			      struct throttle_fan_curve *curve)
+{
+	struct fan_curve_data *dat = &curve->cpu;
+
+	if (device == ASUS_WMI_DEVID_GPU_FAN_CURVE)
+		dat = &curve->gpu;
+
+	return scnprintf(buf, PAGE_SIZE, "%d:%d,%d:%d,%d:%d,%d:%d,%d:%d,%d:%d,%d:%d,%d:%d\n",
+			dat->temps[0], dat->percents[0],
+			dat->temps[1], dat->percents[1],
+			dat->temps[2], dat->percents[2],
+			dat->temps[3], dat->percents[3],
+			dat->temps[4], dat->percents[4],
+			dat->temps[5], dat->percents[5],
+			dat->temps[6], dat->percents[6],
+			dat->temps[7], dat->percents[7]);
+}
+
+/*
+ * The expected input is of the format
+ *     "30:1,49:2,59:3,69:4,79:31,89:49,99:56,109:58"
+ * where a pair is 30:1, with 30 = temperature, and 1 = percentage.
+ *
+ * "dev" is the related WMI method such as ASUS_WMI_DEVID_CPU_FAN_CURVE.
+*/
+static int fan_curve_write(struct asus_wmi *asus, u32 dev, struct fan_curve_data *curve)
+{
+	int ret;
+	u32 arg1, arg2, arg3, arg4;
+
+	arg1 = curve->temps[0];
+	arg2 = curve->temps[4];
+	arg1 += curve->temps[1] << 8;
+	arg2 += curve->temps[5] << 8;
+	arg1 += curve->temps[2] << 16;
+	arg2 += curve->temps[6] << 16;
+	arg1 += curve->temps[3] << 24;
+	arg2 += curve->temps[7] << 24;
+
+
+	arg3 = curve->percents[0];
+	arg4 = curve->percents[4];
+	arg3 += curve->percents[1] << 8;
+	arg4 += curve->percents[5] << 8;
+	arg3 += curve->percents[2] << 16;
+	arg4 += curve->percents[6] << 16;
+	arg3 += curve->percents[3] << 24;
+	arg4 += curve->percents[7] << 24;
+
+	return asus_wmi_evaluate_method5(ASUS_WMI_METHODID_DEVS, dev,
+					arg1, arg2, arg3, arg4, &ret);
+}
+
+static int fan_curve_write_data(struct asus_wmi *asus)
+{
+	struct throttle_fan_curve *curve_data = NULL;
+	int err, mode;
+
+	mode = asus->throttle_thermal_policy_mode;
+
+	if (mode == ASUS_THROTTLE_THERMAL_POLICY_DEFAULT) {
+		curve_data = &asus->throttle_fan_curves[FAN_CURVE_PROFILE_BALANCED];
+	} else if (mode == ASUS_THROTTLE_THERMAL_POLICY_OVERBOOST) {
+		curve_data = &asus->throttle_fan_curves[FAN_CURVE_PROFILE_PERFORMANCE];
+	} else if (mode == ASUS_THROTTLE_THERMAL_POLICY_SILENT) {
+		curve_data = &asus->throttle_fan_curves[FAN_CURVE_PROFILE_QUIET];
+	}
+
+	if (curve_data == NULL)
+		return 0;
+
+	if (asus->cpu_fan_curve_available && curve_data->enabled) {
+		err = fan_curve_write(asus, ASUS_WMI_DEVID_CPU_FAN_CURVE,
+				      &curve_data->cpu);
+		if (err)
+			return err;
+	}
+
+	if (asus->gpu_fan_curve_available && curve_data->enabled) {
+		err = fan_curve_write(asus, ASUS_WMI_DEVID_GPU_FAN_CURVE,
+				      &curve_data->gpu);
+		if (err)
+			return err;
+	}
+
+	return 0;
+}
+
+static ssize_t fan_curve_store(struct asus_wmi *asus, const char *buf,
+				size_t count, u32 dev,
+				struct throttle_fan_curve *curve)
+{
+	char *set, *pair, *set_end, *pair_end, *tmp_buf;
+	u8 temps[NUM_FAN_CURVE_POINTS];
+	u8 percents[NUM_FAN_CURVE_POINTS];
+	int err, ret;
+
+	char *set_delimiter = ",";
+	char *pair_delimiter = ":";
+	bool pair_start = true;
+	u32 prev_percent = 0;
+	u32 prev_temp = 0;
+	u32 percent = 0;
+	u32 temp = 0;
+	u32 position = 0;
+
+	/* Allow a user to write "" or " " to erase a curve setting */
+	if (strlen(buf) <= 1 || strcmp(buf, " \n") == 0) {
+		if (dev == ASUS_WMI_DEVID_CPU_FAN_CURVE) {
+			memcpy(&curve->cpu, &curve->cpu_default,
+			       NUM_FAN_CURVE_DATA);
+		} else {
+			memcpy(&curve->gpu, &curve->gpu_default,
+				NUM_FAN_CURVE_DATA);
+		}
+		err = throttle_thermal_policy_write(asus);
+		if (err)
+			return err;
+		return count;
+	}
+
+	/* parse the buf */
+	tmp_buf = set_end = pair_end = kstrdup(buf, GFP_KERNEL);
+
+	while( (set = strsep(&set_end, set_delimiter)) != NULL ) {
+		pair_start = true;
+		while( (pair = strsep(&tmp_buf, pair_delimiter)) != NULL ) {
+			err = kstrtouint(pair, 10, &ret);
+			if (err) {
+				kfree(tmp_buf);
+				return err;
+			}
+
+			if (pair_start) {
+				temp = ret;
+				pair_start = false;
+			} else {
+				percent = ret;
+			}
+		}
+
+		if (temp < prev_temp || percent < prev_percent || percent > 100) {
+			pr_info("Fan curve invalid");
+				pr_info("A value is sequentially lower or percentage is > 100");
+			kfree(tmp_buf);
+			return -EINVAL;
+		}
+
+		temps[position] = temp;
+		percents[position] = percent;
+		position += 1;
+
+		prev_temp = temp;
+		prev_percent = percent;
+	}
+	kfree(tmp_buf);
+
+	if (dev == ASUS_WMI_DEVID_CPU_FAN_CURVE) {
+		memcpy(&curve->cpu.temps, &temps,
+			NUM_FAN_CURVE_POINTS);
+		memcpy(&curve->cpu.percents, &percents,
+			NUM_FAN_CURVE_POINTS);
+	} else {
+		memcpy(&curve->gpu.temps, &temps,
+			NUM_FAN_CURVE_POINTS);
+		memcpy(&curve->gpu.percents, &percents,
+			NUM_FAN_CURVE_POINTS);
+	}
+
+	/* Maybe activate fan curve if in associated mode */
+	err = throttle_thermal_policy_write(asus);
+	if (err)
+		return err;
+
+	return count;
+}
+
+/*
+ * CPU Fan Curves
+*/
+
+static ssize_t cpu_fan_curve_balanced_show(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	struct asus_wmi *asus = dev_get_drvdata(dev);
+	return fan_curve_show(buf, ASUS_WMI_DEVID_CPU_FAN_CURVE,
+		&asus->throttle_fan_curves[FAN_CURVE_PROFILE_BALANCED]);
+}
+
+static ssize_t cpu_fan_curve_balanced_store(struct device *dev,
+				    struct device_attribute *attr,
+				    const char *buf, size_t count)
+{
+    struct asus_wmi *asus = dev_get_drvdata(dev);
+    return fan_curve_store(asus, buf, count, ASUS_WMI_DEVID_CPU_FAN_CURVE,
+                &asus->throttle_fan_curves[FAN_CURVE_PROFILE_BALANCED]);
+}
+
+static DEVICE_ATTR_RW(cpu_fan_curve_balanced);
+
+static ssize_t cpu_fan_curve_performance_show(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	struct asus_wmi *asus = dev_get_drvdata(dev);
+	return fan_curve_show(buf, ASUS_WMI_DEVID_CPU_FAN_CURVE,
+		&asus->throttle_fan_curves[FAN_CURVE_PROFILE_PERFORMANCE]);
+}
+
+static ssize_t cpu_fan_curve_performance_store(struct device *dev,
+				    struct device_attribute *attr,
+				    const char *buf, size_t count)
+{
+    struct asus_wmi *asus = dev_get_drvdata(dev);
+    return fan_curve_store(asus, buf, count, ASUS_WMI_DEVID_CPU_FAN_CURVE,
+                &asus->throttle_fan_curves[FAN_CURVE_PROFILE_PERFORMANCE]);
+}
+
+static DEVICE_ATTR_RW(cpu_fan_curve_performance);
+
+static ssize_t cpu_fan_curve_quiet_show(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	struct asus_wmi *asus = dev_get_drvdata(dev);
+	return fan_curve_show(buf, ASUS_WMI_DEVID_CPU_FAN_CURVE,
+		&asus->throttle_fan_curves[FAN_CURVE_PROFILE_QUIET]);
+}
+
+static ssize_t cpu_fan_curve_quiet_store(struct device *dev,
+				    struct device_attribute *attr,
+				    const char *buf, size_t count)
+{
+    struct asus_wmi *asus = dev_get_drvdata(dev);
+    return fan_curve_store(asus, buf, count, ASUS_WMI_DEVID_CPU_FAN_CURVE,
+                &asus->throttle_fan_curves[FAN_CURVE_PROFILE_QUIET]);
+}
+
+static DEVICE_ATTR_RW(cpu_fan_curve_quiet);
+
+/*
+ * GPU Fan Curves
+*/
+
+static ssize_t gpu_fan_curve_balanced_show(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	struct asus_wmi *asus = dev_get_drvdata(dev);
+	return fan_curve_show(buf, ASUS_WMI_DEVID_GPU_FAN_CURVE,
+		&asus->throttle_fan_curves[FAN_CURVE_PROFILE_BALANCED]);
+}
+
+static ssize_t gpu_fan_curve_balanced_store(struct device *dev,
+				    struct device_attribute *attr,
+				    const char *buf, size_t count)
+{
+    struct asus_wmi *asus = dev_get_drvdata(dev);
+    return fan_curve_store(asus, buf, count, ASUS_WMI_DEVID_GPU_FAN_CURVE,
+                &asus->throttle_fan_curves[FAN_CURVE_PROFILE_BALANCED]);
+}
+
+static DEVICE_ATTR_RW(gpu_fan_curve_balanced);
+
+static ssize_t gpu_fan_curve_performance_show(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	struct asus_wmi *asus = dev_get_drvdata(dev);
+	return fan_curve_show(buf, ASUS_WMI_DEVID_GPU_FAN_CURVE,
+		&asus->throttle_fan_curves[FAN_CURVE_PROFILE_PERFORMANCE]);
+}
+
+static ssize_t gpu_fan_curve_performance_store(struct device *dev,
+				    struct device_attribute *attr,
+				    const char *buf, size_t count)
+{
+    struct asus_wmi *asus = dev_get_drvdata(dev);
+    return fan_curve_store(asus, buf, count, ASUS_WMI_DEVID_GPU_FAN_CURVE,
+                &asus->throttle_fan_curves[FAN_CURVE_PROFILE_PERFORMANCE]);
+}
+
+static DEVICE_ATTR_RW(gpu_fan_curve_performance);
+
+static ssize_t gpu_fan_curve_quiet_show(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	struct asus_wmi *asus = dev_get_drvdata(dev);
+	return fan_curve_show(buf, ASUS_WMI_DEVID_GPU_FAN_CURVE,
+		&asus->throttle_fan_curves[FAN_CURVE_PROFILE_QUIET]);
+}
+
+static ssize_t gpu_fan_curve_quiet_store(struct device *dev,
+				    struct device_attribute *attr,
+				    const char *buf, size_t count)
+{
+    struct asus_wmi *asus = dev_get_drvdata(dev);
+    return fan_curve_store(asus, buf, count, ASUS_WMI_DEVID_GPU_FAN_CURVE,
+                &asus->throttle_fan_curves[FAN_CURVE_PROFILE_QUIET]);
+}
+
+static DEVICE_ATTR_RW(gpu_fan_curve_quiet);
+
+/*
+ * Profiles with enabled fan curve setting
+*/
+
+static int enabled_fan_curve_profiles_write(struct asus_wmi *asus,
+					    const char *names)
+{
+    char *buf, *set, *set_end;
+    int err, index;
+
+    buf = set_end = kstrdup(names, GFP_KERNEL);
+
+	/* Reset before checking */
+	asus->throttle_fan_curves[FAN_CURVE_PROFILE_BALANCED].enabled = false;
+	asus->throttle_fan_curves[FAN_CURVE_PROFILE_QUIET].enabled = false;
+	asus->throttle_fan_curves[FAN_CURVE_PROFILE_PERFORMANCE].enabled = false;
+
+	while( (set = strsep(&set_end, " ")) != NULL ) {
+		index = sysfs_match_string(fan_curve_names, set);
+		if (index >= 0) {
+			asus->throttle_fan_curves[index].enabled = true;
+		}
+	}
+
+	err = throttle_thermal_policy_write(asus);
+	if (err)
+		return err;
+
+	kfree(buf);
+
+	return 0;
+}
+
+static ssize_t enabled_fan_curve_profiles_show(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	struct asus_wmi *asus = dev_get_drvdata(dev);
+	int i, len = 0;
+
+	for (i = 0; i < NUM_FAN_CURVE_PROFILES; i++) {
+		if (asus->throttle_fan_curves[i].enabled) 	{
+			len += sysfs_emit_at(buf, len, fan_curve_names[i]);
+			len += sysfs_emit_at(buf, len, " ");
+		}
+	}
+
+	len += sysfs_emit_at(buf, len, "\n");
+	return len;
+}
+
+static ssize_t enabled_fan_curve_profiles_store(struct device *dev,
+				    struct device_attribute *attr,
+				    const char *buf, size_t count)
+{
+    struct asus_wmi *asus = dev_get_drvdata(dev);
+	int err;
+
+	err = enabled_fan_curve_profiles_write(asus, buf);
+	if (err)
+		return err;
+
+    return count;
+}
+
+static DEVICE_ATTR_RW(enabled_fan_curve_profiles);
+
 /* Throttle thermal policy ****************************************************/
 
 static int throttle_thermal_policy_check_present(struct asus_wmi *asus)
@@ -2092,6 +2669,10 @@ static int throttle_thermal_policy_write(struct asus_wmi *asus)
 		return -EIO;
 	}
 
+	err = fan_curve_write_data(asus);
+	if (err)
+		return err;
+
 	return 0;
 }
 
@@ -2711,6 +3292,13 @@ static struct attribute *platform_attributes[] = {
 	&dev_attr_als_enable.attr,
 	&dev_attr_fan_boost_mode.attr,
 	&dev_attr_throttle_thermal_policy.attr,
+	&dev_attr_cpu_fan_curve_balanced.attr,
+	&dev_attr_cpu_fan_curve_performance.attr,
+	&dev_attr_cpu_fan_curve_quiet.attr,
+    &dev_attr_gpu_fan_curve_balanced.attr,
+	&dev_attr_gpu_fan_curve_performance.attr,
+	&dev_attr_gpu_fan_curve_quiet.attr,
+	&dev_attr_enabled_fan_curve_profiles.attr,
 	&dev_attr_panel_od.attr,
 	NULL
 };
@@ -2741,6 +3329,20 @@ static umode_t asus_sysfs_is_visible(struct kobject *kobj,
 		ok = asus->fan_boost_mode_available;
 	else if (attr == &dev_attr_throttle_thermal_policy.attr)
 		ok = asus->throttle_thermal_policy_available;
+	else if (attr == &dev_attr_cpu_fan_curve_balanced.attr)
+		ok = asus->cpu_fan_curve_available;
+	else if (attr == &dev_attr_cpu_fan_curve_performance.attr)
+		ok = asus->cpu_fan_curve_available;
+	else if (attr == &dev_attr_cpu_fan_curve_quiet.attr)
+		ok = asus->cpu_fan_curve_available;
+    else if (attr == &dev_attr_gpu_fan_curve_balanced.attr)
+		ok = asus->gpu_fan_curve_available;
+	else if (attr == &dev_attr_gpu_fan_curve_performance.attr)
+		ok = asus->gpu_fan_curve_available;
+	else if (attr == &dev_attr_gpu_fan_curve_quiet.attr)
+		ok = asus->gpu_fan_curve_available;
+	else if (attr == &dev_attr_enabled_fan_curve_profiles.attr)
+		ok = asus->cpu_fan_curve_available || asus->gpu_fan_curve_available;
 	else if (attr == &dev_attr_panel_od.attr)
 		ok = asus->panel_overdrive_available;
 
@@ -2904,7 +3506,7 @@ static int show_call(struct seq_file *m, void *data)
 	if (ACPI_FAILURE(status))
 		return -EIO;
 
-	obj = (union acpi_object *)output.pointer;
+	obj = output.pointer;
 	if (obj && obj->type == ACPI_TYPE_INTEGER)
 		seq_printf(m, "%#x(%#x, %#x) = %#x\n", asus->debug.method_id,
 			   asus->debug.dev_id, asus->debug.ctrl_param,
@@ -3016,6 +3618,16 @@ static int asus_wmi_add(struct platform_device *pdev)
 	else
 		throttle_thermal_policy_set_default(asus);
 
+	err = custom_fan_check_present(asus, &asus->cpu_fan_curve_available,
+			ASUS_WMI_DEVID_CPU_FAN_CURVE);
+	if (err)
+		goto fail_custom_fan_curve;
+
+	err = custom_fan_check_present(asus, &asus->gpu_fan_curve_available,
+			ASUS_WMI_DEVID_GPU_FAN_CURVE);
+	if (err)
+		goto fail_custom_fan_curve;
+
 	err = platform_profile_setup(asus);
 	if (err)
 		goto fail_platform_profile_setup;
@@ -3109,6 +3721,7 @@ static int asus_wmi_add(struct platform_device *pdev)
 	asus_wmi_sysfs_exit(asus->platform_device);
 fail_sysfs:
 fail_throttle_thermal_policy:
+fail_custom_fan_curve:
 fail_platform_profile_setup:
 	if (asus->platform_profile_support)
 		platform_profile_remove();
diff --git a/include/linux/platform_data/x86/asus-wmi.h b/include/linux/platform_data/x86/asus-wmi.h
index 17dc5cb6f3f2..a571b47ff362 100644
--- a/include/linux/platform_data/x86/asus-wmi.h
+++ b/include/linux/platform_data/x86/asus-wmi.h
@@ -77,6 +77,8 @@
 #define ASUS_WMI_DEVID_THERMAL_CTRL	0x00110011
 #define ASUS_WMI_DEVID_FAN_CTRL		0x00110012 /* deprecated */
 #define ASUS_WMI_DEVID_CPU_FAN_CTRL	0x00110013
+#define ASUS_WMI_DEVID_CPU_FAN_CURVE	0x00110024
+#define ASUS_WMI_DEVID_GPU_FAN_CURVE	0x00110025
 
 /* Power */
 #define ASUS_WMI_DEVID_PROCESSOR_STATE	0x00120012
-- 
2.31.1

